import math
import time
import random
"""
# 福字顶点数据，格式（x，y，z）笛卡尔坐标系
point = [
    [3, 6, 0], [3, 17, 0], [3, 20, 0], [3, 34, 0],
    [7, 6, 0], [7, 17, 0], [7, 20, 0], [7, 34, 0],
    [10, 5, 0], [10, 18, 0], [10, 20, 0], [10, 34, 0],
    [13, 24, 0], [13, 30, 0], [14, 5, 0], [14, 10, 0],
    [14, 13, 0], [14, 18, 0], [15, 24, 0], [15, 30, 0],
    [18, 20, 0], [18, 34, 0], [19, 5, 0], [19, 8, 0],
    [19, 15, 0], [19, 18, 0], [20, 20, 0], [20, 34, 0],
    [24, 23, 0], [24, 26, 0], [24, 28, 0], [24, 31, 0],
    [27, 23, 0], [27, 26, 0], [27, 28, 0], [27, 31, 0],
    [30, 23, 0], [30, 26, 0], [30, 28, 0], [30, 31, 0],
    [33, 5, 0], [33, 8, 0], [33, 15, 0], [33, 18, 0],
    [33, 23, 0], [33, 26, 0], [33, 28, 0], [33, 31, 0],
    [37, 10, 0], [37, 13, 0], [37, 20, 0], [37, 34, 0],
    # 福字正面顶点
    [3, 6, 4], [3, 17, 4], [3, 20, 4], [3, 34, 4],
    [7, 6, 4], [7, 17, 4], [7, 20, 4], [7, 34, 4],
    [10, 5, 4], [10, 18, 4], [10, 20, 4], [10, 34, 4],
    [13, 24, 4], [13, 30, 4], [14, 5, 4], [14, 10, 4],
    [14, 13, 4], [14, 18, 4], [15, 24, 4], [15, 30, 4],
    [18, 20, 4], [18, 34, 4], [19, 5, 4], [19, 8, 4],
    [19, 15, 4], [19, 18, 4], [20, 20, 4], [20, 34, 4],
    [24, 23, 4], [24, 26, 4], [24, 28, 4], [24, 31, 4],
    [27, 23, 4], [27, 26, 4], [27, 28, 4], [27, 31, 4],
    [30, 23, 4], [30, 26, 4], [30, 28, 4], [30, 31, 4],
    [33, 5, 4], [33, 8, 4], [33, 15, 4], [33, 18, 4],
    [33, 23, 4], [33, 26, 4], [33, 28, 4], [33, 31, 4],
    [37, 10, 4], [37, 13, 4], [37, 20, 4], [37, 34, 4]
    # 福字背面顶点
]

# 福字边数据，存储的是顶点数据的下标
edge = [
    (0, 1), (1, 5), (5, 4), (4, 0),
    (2, 3), (3, 7), (7, 6), (6, 2),
    (8, 9), (9, 17), (17, 16), (16, 49), (49, 48), (48, 15), (15, 14), (14, 8),
    (22, 23), (23, 41), (41, 40), (40, 22),
    (24, 25), (25, 43), (43, 42), (42, 24),
    (10, 11), (11, 21), (21, 20), (20, 10),
    (12, 13), (13, 19), (19, 18), (18, 12),
    (26, 27), (27, 51), (51, 50), (50, 26),
    (28, 29), (29, 33), (33, 32), (32, 28),
    (30, 31), (31, 35), (35, 34), (34, 30),
    (38, 39), (39, 47), (47, 46), (46, 38),
    (36, 37), (37, 45), (45, 44), (44, 36),
    #福字正面的边
    (0, 52), (1, 53), (2, 54), (3, 55), (4, 56), (5, 57), (6, 58), (7, 59), (8, 60), (9, 61),
    (10, 62), (11, 63), (12, 64), (13, 65), (14, 66), (15, 67), (16, 68), (17, 69), (18, 70), (19, 71),
    (20, 72), (21, 73), (22, 74), (23, 75), (24, 76), (25, 77), (26, 78), (27, 79), (28, 80), (29, 81),
    (30, 82), (31, 83), (32, 84), (33, 85), (34, 86), (35, 87), (36, 88), (37, 89), (38, 90), (39, 91),
    (40, 92), (41, 93), (42, 94), (43, 95), (44, 96), (45, 97), (46, 98), (47, 99), (48, 100), (49, 101),
    (50, 102), (51, 103),
    #正面与背面相连的边
    (52, 53), (53, 57), (57, 56), (56, 52),
    (54, 55), (55, 59), (59, 58), (58, 54),
    (60, 61), (61, 69), (69, 68), (68, 101), (101, 100), (100, 67), (67, 66), (66, 60),
    (74, 75), (75, 93), (93, 92), (92, 74),
    (76, 77), (77, 95), (95, 94), (94, 76),
    (62, 63), (63, 73), (73, 72), (72, 62),
    (64, 65), (65, 71), (71, 70), (70, 64),
    (78, 79), (79, 103), (103, 102), (102, 78),
    (80, 81), (81, 85), (85, 84), (84, 80),
    (82, 83), (83, 87), (87, 86), (86, 82),
    (90, 91), (91, 99), (99, 98), (98, 90),
    (88, 89), (89, 97), (97, 96), (96, 88)
    #福字背面的边
]
# 渲染时随机切换的字符
CHAR = ['恭','喜','發','财','祥','瑞','福','吉','禧','佳']
# 渲染时字符的颜色
COLOR = [31,91,33,93]
# 画布的填充字符
CANVAS_CHAR = '  '
"""
#￥符号的顶点数据
point = [
    [3, 2, 0], [3, 12, 0], [3, 36, 0], [3, 47, 0], [15, 24, 0],
    [19, 5, 0], [19, 18, 0], [19, 32, 0], [19, 44, 0], [25, 5, 0],
    [25, 20, 0], [25, 29, 0], [25, 44, 0], [30, 4, 0], [30, 20, 0],
    [30, 29, 0], [30, 45, 0], [35, 4, 0], [35, 20, 0], [35, 29, 0],
    [35, 45, 0], [44, 20, 0], [44, 29, 0],
    # ￥符号正面的顶点数据
    [3, 2, 4], [3, 12, 4], [3, 36, 4], [3, 47, 4], [15, 24, 4],
    [19, 5, 4], [19, 18, 4], [19, 32, 4], [19, 44, 4], [25, 5, 4],
    [25, 20, 4], [25, 29, 4], [25, 44, 4], [30, 4, 4], [30, 20, 4],
    [30, 29, 4], [30, 45, 4], [35, 4, 4], [35, 20, 4], [35, 29, 4],
    [35, 45, 4], [44, 20, 4], [44, 29, 4]
    #￥符号背面的顶点数据
]

# ￥符号边的数据
edge = [(0,1),(1,4),(4,2),(2,3),(3,7),(7,8),(8,12),(12,11),
(11,15),(15,16),(16,20),(20,19),(19,22),(22,21),(21,18),
(18,17),(17,13),(13,14),(14,10),(10,9),(9,5),(5,6),(6,0),
#￥符号正面边的数据
(0, 23), (1, 24), (2, 25), (3, 26), (4, 27), (5, 28), (6, 29),
(7, 30), (8, 31), (9, 32), (10, 33), (11, 34), (12, 35), (13, 36),
(14, 37), (15, 38), (16, 39), (17, 40), (18, 41), (19, 42), (20, 43),
(21, 44), (22, 44),
#￥符号正面与背面相连的边数据
(23, 24), (24, 27), (27, 25), (25, 26), (26, 30), (30, 31), (31, 35), (35, 34),
(34, 38), (38, 39), (39, 43), (43, 42), (42, 45), (45, 44), (44, 41),
(41, 40), (40, 36), (36, 37), (37, 33), (33, 32), (32, 28), (28, 29), (29, 23)
# ￥符号背面边的数据
]
# 渲染时随机切换的字符
CHAR = ['¥','$','£','₩','₽','R','₹','฿','¢']
# 渲染时字符的颜色
COLOR = [30,31,32,33,34,35,36,37]
# 画布的填充字符
CANVAS_CHAR = ' '


VERTICES = point
EDGES = edge

def random_colored_char():
    char = random.choice(CHAR)
    color = COLOR[random.randint(0, len(COLOR)-1)]
    return f'\033[{color}m{char}\033[0m'
# 投影函数
def project(point, y_compress=1):
    """
    将旋转后的3D点投影到2D整数坐标。
    参数：
        point : (x, y, z) 已旋转的三维点
        y_compress : 终端字符宽高比修正因子（默认0.5）
    返回：
        (canvas_x, canvas_y)  未经平移的缩放后坐标
    """
    x, y, z = point
    # 坐标轴交换：screen_x = y , screen_y = x
    screen_x = y
    screen_y = x
    # Y轴压缩,终端的字符间的宽高不相同
    screen_y = screen_y * y_compress
    # 等比放大使模型在画布上大小合适
    scale = 1.7
    # 这里使用正交投影，因为方便简单
    canvas_x = int(screen_x * scale)
    canvas_y = int(screen_y * scale)
    return canvas_x, canvas_y


# 旋转函数
def rotate_x(point, angle_deg, y_center):
    x, y, z = point
    # 将坐标系y轴拉到模型中心
    y_centered = y - y_center
    # 绕x轴旋转的三维变换公式
    # 因为在project投影函数中将坐标系的x轴映射到了屏幕y轴，将Y轴映射到了屏幕x轴
    # 所以这里是按照坐标系的x轴旋转
    angle_rad = math.radians(angle_deg)
    y_rot = y_centered * math.cos(angle_rad) - z * math.sin(angle_rad)
    z_rot = y_centered * math.sin(angle_rad) + z * math.cos(angle_rad)
    # 这里将Y的坐标拉回原来的坐标，以使其在画布上能够正确显示
    y_final = y_rot + y_center
    return (x, y_final, z_rot)

# Bresenham直线算法,计算两个点连线
def bresenham(x1, y1, x2, y2):
    points = []
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1
    err = dx - dy
    while True:
        points.append((x1, y1))
        if x1 == x2 and y1 == y2:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x1 += sx
        if e2 < dx:
            err += dx
            y1 += sy
    return points


def draw_model(rotation_angle=0):
    # 画布尺寸
    canvas_rows = 35
    canvas_cols = 85
    canvas = [[CANVAS_CHAR for _ in range(canvas_cols)] for _ in range(canvas_rows)]

    # 旋转中心，基于模型原始Y坐标
    all_y = [v[1] for v in VERTICES]
    y_center = (min(all_y) + max(all_y)) / 2

    # 投影所有顶点
    projected = []
    for v in VERTICES:
        # 生成以指定角度旋转后的坐标
        rotated = rotate_x(v, rotation_angle, y_center)
        # 将这个坐标投影到二维画面
        proj = project(rotated, y_compress=0.5)
        projected.append(proj)

    # 绘制所有边
    for (i1, i2) in EDGES:
        x1, y1 = projected[i1]
        x2, y2 = projected[i2]

        # 边界裁剪，以免输出的画面超过画布产生IndexError
        x1 = max(0, min(x1, canvas_cols - 1))
        y1 = max(0, min(y1, canvas_rows - 1))
        x2 = max(0, min(x2, canvas_cols - 1))
        y2 = max(0, min(y2, canvas_rows - 1))
        # 通过bresenham算法生成边
        for x, y in bresenham(x1, y1, x2, y2):
            if 0 <= x < canvas_cols and 0 <= y < canvas_rows:
                canvas[y][x] = random_colored_char()


    # 标题信息
    title = f"旋转{rotation_angle:.1f}°"
    info = f"顶点数: {len(VERTICES)} | 边数: {len(EDGES)}"
    canvas_str = f"{title:^{canvas_cols}}\n"
    canvas_str += f"{info:^{canvas_cols}}\n"
    canvas_str += '\n'.join(''.join(row) for row in canvas)
    return canvas_str

# 清空终端
def clear_terminal():
    print("\033[H\033[2J", end="", flush=True)


def animate_model():
    angle = 0
    step = 1
    try:
        while True:
            clear_terminal()
            print(draw_model(angle))
            angle = (angle + step) % 360
            time.sleep(0.05)
    except KeyboardInterrupt:
        clear_terminal()


if __name__ == "__main__":
    animate_model()
